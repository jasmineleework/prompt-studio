import { create } from 'zustand'
import { Version } from '@/types'
import { getDB } from './database'
import { v4 as uuidv4 } from 'uuid'

interface VersionState {
  versions: Version[]
  currentVersion: Version | null
  isLoading: boolean
  loadVersions: (projectId: string) => Promise<void>
  createVersion: (projectId: string, content: string, description?: string, projectName?: string) => Promise<Version>
  selectVersion: (versionId: string) => void
  setCurrentVersionNumber: (versionNumber: number) => void
  getLatestVersion: (projectId: string) => Version | null
}

// 使用共享的数据库配置

function countWords(text: string): number {
  return text.trim().split(/\s+/).filter(word => word.length > 0).length
}

export const useVersionStore = create<VersionState>((set, get) => ({
  versions: [],
  currentVersion: null,
  isLoading: false,

  loadVersions: async (projectId: string) => {
    set({ isLoading: true })
    try {
      const db = await getDB()
      
      // 获取项目信息以确定当前版本
      const project = await db.get('projects', projectId)
      
      const tx = db.transaction('versions', 'readonly')
      const index = tx.store.index('projectId')
      const versions = await index.getAll(projectId)
      
      versions.sort((a, b) => b.versionNumber - a.versionNumber)
      
      // 根据项目的currentVersion字段选择正确的版本
      let currentVersion = null
      if (project && project.currentVersion && versions.length > 0) {
        currentVersion = versions.find(v => v.versionNumber === project.currentVersion) || versions[0]
      } else if (versions.length > 0) {
        currentVersion = versions[0]
      }
      
      set({ 
        versions,
        currentVersion,
        isLoading: false 
      })
    } catch (error) {
      console.error('Failed to load versions:', error)
      set({ isLoading: false })
    }
  },

  createVersion: async (projectId: string, content: string, description?: string, projectName?: string) => {
    const versions = get().versions.filter(v => v.projectId === projectId)
    const latestVersion = versions.reduce((max, v) => 
      v.versionNumber > max ? v.versionNumber : max, 0
    )
    
    const newVersion: Version = {
      id: uuidv4(),
      projectId,
      versionNumber: latestVersion + 1,
      content,
      timestamp: new Date(),
      description,
      autoGenerated: !description,
      metadata: {
        lines: content.split('\n').length,
        characters: content.length,
        words: countWords(content),
        changeType: 'minor'
      },
      parentVersion: get().currentVersion?.id
    }

    try {
      const db = await getDB()
      await db.add('versions', newVersion)
      const updatedVersions = [...get().versions, newVersion]
      set({ 
        versions: updatedVersions.sort((a, b) => b.versionNumber - a.versionNumber),
        currentVersion: newVersion 
      })
      
      // Update project's currentVersion
      const project = await db.get('projects', projectId)
      if (project) {
        project.currentVersion = newVersion.versionNumber
        await db.put('projects', project)
      }
      
      // 同步保存到本地文件
      if (projectName) {
        try {
          // 不再需要文件夹信息，所有文件都保存在项目自己的目录下
          const saveResponse = await fetch('/api/save-local', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              projectName,
              folderName: null, // 保持兼容性，但不再使用
              versionNumber: newVersion.versionNumber,
              content
            })
          })
          
          if (!saveResponse.ok) {
            const errorData = await saveResponse.json()
            throw new Error(`Failed to save file locally: ${errorData.error || 'Unknown error'}`)
          }
          
          const saveResult = await saveResponse.json()
          if (!saveResult.success) {
            throw new Error(`Save failed: ${saveResult.error || 'Unknown error'}`)
          }
          
          console.log(`✅ Version saved to local file: ${saveResult.path}`)
          
          // 如果有描述，同步保存到 structure.json
          if (description) {
            const structureResponse = await fetch('/api/structure', {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                operation: 'updateVersionDescription',
                data: {
                  projectName,
                  versionNumber: newVersion.versionNumber,
                  description
                }
              })
            })
            
            if (!structureResponse.ok) {
              console.error('Failed to update structure.json with version description')
            }
          }
        } catch (localError) {
          console.error('❌ Failed to save locally:', localError)
          // 抛出错误让用户知道保存失败
          throw new Error(`本地文件保存失败: ${localError instanceof Error ? localError.message : '未知错误'}`)
        }
      }
      
      return newVersion
    } catch (error) {
      console.error('Failed to create version:', error)
      throw error
    }
  },

  selectVersion: (versionId: string) => {
    const version = get().versions.find(v => v.id === versionId)
    if (version) {
      set({ currentVersion: version })
    }
  },

  setCurrentVersionNumber: (versionNumber: number) => {
    const version = get().versions.find(v => v.versionNumber === versionNumber)
    if (version) {
      set({ currentVersion: version })
    }
  },

  getLatestVersion: (projectId: string) => {
    const projectVersions = get().versions.filter(v => v.projectId === projectId)
    if (projectVersions.length === 0) return null
    return projectVersions.reduce((latest, v) => 
      v.versionNumber > latest.versionNumber ? v : latest
    )
  }
}))